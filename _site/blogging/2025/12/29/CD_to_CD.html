<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.3 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>From Continuous Delivery to Continuous Deployment - Cognitive offloading</title>
<meta name="description" content="After reading Accelerate by Nicole Forsgren, Jez Humble, and Gene Kim, I started rethinking what CD actually means. For years, I worked in environments where CD meant Continuous Delivery: code ready to deploy, waiting for approval.">


  <meta name="author" content="J. Lemaire">
  
  <meta property="article:author" content="J. Lemaire">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Cognitive offloading">
<meta property="og:title" content="From Continuous Delivery to Continuous Deployment">
<meta property="og:url" content="http://localhost:4000/blogging/2025/12/29/CD_to_CD.html">


  <meta property="og:description" content="After reading Accelerate by Nicole Forsgren, Jez Humble, and Gene Kim, I started rethinking what CD actually means. For years, I worked in environments where CD meant Continuous Delivery: code ready to deploy, waiting for approval.">







  <meta property="article:published_time" content="2025-12-29T00:00:00+01:00">






<link rel="canonical" href="http://localhost:4000/blogging/2025/12/29/CD_to_CD.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Cognitive offloading Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Cognitive offloading
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/"
                
                
              >Home</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">J. Lemaire</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>Emptying the mind, one article at a time</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="From Continuous Delivery to Continuous Deployment">
    <meta itemprop="description" content="After reading Accelerate by Nicole Forsgren, Jez Humble, and Gene Kim, I started rethinking what CD actually means. For years, I worked in environments where CD meant Continuous Delivery: code ready to deploy, waiting for approval.">
    <meta itemprop="datePublished" content="2025-12-29T00:00:00+01:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="http://localhost:4000/blogging/2025/12/29/CD_to_CD.html" itemprop="url">From Continuous Delivery to Continuous Deployment
</a>
          </h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#delivery-vs-deployment">Delivery vs. Deployment</a></li><li><a href="#key-concept-decoupling-deployment-from-release">Key Concept: Decoupling Deployment from Release</a></li><li><a href="#the-mechanic-feature-flags">The Mechanic: Feature Flags</a><ul><li><a href="#feature-flag-frameworks">Feature Flag Frameworks</a></li><li><a href="#feature-flags-in-code">Feature Flags in Code</a></li></ul></li><li><a href="#safe-deployment-canary-releases">Safe Deployment: Canary Releases</a></li><li><a href="#environments-ephemeral-over-static">Environments: Ephemeral over Static</a></li><li><a href="#branching-trunk-based-development">Branching: Trunk-Based Development</a></li><li><a href="#measuring-success-dora-metrics">Measuring Success: DORA Metrics</a></li><li><a href="#accelerating-even-faster">Accelerating Even Faster</a><ul><li><a href="#1-predictive-test-selection">1. Predictive Test Selection</a></li><li><a href="#2-deployment-risk-scoring">2. Deployment Risk Scoring</a></li><li><a href="#3-smart-root-cause-analysis">3. Smart Root Cause Analysis</a></li><li><a href="#4-gitops-from-push-to-pull">4. GitOps: From Push to Pull</a></li><li><a href="#5-finops-integration">5. FinOps Integration</a></li></ul></li><li><a href="#the-bleeding-edge-agentic-devops">The Bleeding Edge: Agentic DevOps</a></li><li><a href="#summary">Summary</a></li><li><a href="#recommended-reading">Recommended Reading</a></li></ul>
            </nav>
          </aside>
        
        <p>After reading <em>Accelerate</em> by Nicole Forsgren, Jez Humble, and Gene Kim, I started rethinking what CD actually means. For years, I worked in environments where CD meant Continuous Delivery: code ready to deploy, waiting for approval.</p>

<p>It is still CI/CD. The difference is you can move faster.</p>

<h2 id="delivery-vs-deployment">Delivery vs. Deployment</h2>

<p><strong>Continuous Delivery</strong>: Code is built, tested, and pushed to a staging environment automatically. It can be deployed to production at any time, but a human decision or a scheduled window triggers the go-live.</p>

<p><strong>Continuous Deployment</strong>: Every change that passes the automated test suite is deployed to Production immediately, without human intervention.</p>

<p>In regulated environments, teams simulate Continuous Deployment by automating Change Request ticket creation and approval based on test evidence. The old world was a manager clicking Approve in ServiceNow. The new world is automated governance: the pipeline generates an attestation document proving that tests passed, security scans completed, and peer review happened. The auditor is satisfied without stopping the assembly line.</p>

<h2 id="key-concept-decoupling-deployment-from-release">Key Concept: Decoupling Deployment from Release</h2>

<p>This is the most important concept I took from Accelerate:</p>

<ul>
  <li><strong>Deployment</strong> (Technical Act): Moving code to the production server. Happens continuously.</li>
  <li><strong>Release</strong> (Business Act): Making the feature visible to the customer. Happens when the business is ready.</li>
</ul>

<p>You can deploy on Tuesday at 10 AM, but release on Friday for a Business launch.</p>

<h2 id="the-mechanic-feature-flags">The Mechanic: Feature Flags</h2>

<p>How do you deploy code in the middle of a sprint without breaking the user experience?</p>

<p><strong>Day 3 of Sprint:</strong> You finish the backend for a new payment feature. It deploys to Prod immediately. Safe because the code is wrapped in a Feature Flag set to <code class="language-plaintext highlighter-rouge">False</code>. Users cannot hit it.</p>

<p><strong>Day 7 of Sprint:</strong> The UI is done. It deploys to Prod. Flag is still <code class="language-plaintext highlighter-rouge">False</code>.</p>

<p><strong>End of Sprint (Review):</strong> You toggle the flag to <code class="language-plaintext highlighter-rouge">True</code> only for internal users to demo it in Production.</p>

<p><strong>Release Day:</strong> The business toggles the flag to <code class="language-plaintext highlighter-rouge">True</code> for 100% of users.</p>

<h3 id="feature-flag-frameworks">Feature Flag Frameworks</h3>

<ul>
  <li><strong>LaunchDarkly</strong> (SaaS, Market Leader): Deep audit logging, RBAC, SSO integration. Expensive at scale.</li>
  <li><strong>Unleash</strong> (Open Source, Self-Hosted): Self-host inside your private cloud. No data leaves your network.</li>
  <li><strong>AWS AppConfig / Azure App Configuration</strong>: Good if you want to avoid buying another tool.</li>
  <li><strong>OpenFeature</strong> (CNCF Project): An open specification that lets you swap vendors without rewriting application code.</li>
</ul>

<h3 id="feature-flags-in-code">Feature Flags in Code</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// OLD WAY: Hardcoded or Config File</span>
<span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">isNewPaymentFlowEnabled</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">runNewPaymentLogic</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// NEW WAY: Feature Flag SDK</span>
<span class="kt">boolean</span> <span class="n">showNewFeature</span> <span class="o">=</span> <span class="n">featureFlagClient</span><span class="o">.</span><span class="na">boolVariation</span><span class="o">(</span>
    <span class="s">"new-payment-flow"</span><span class="o">,</span> <span class="n">userContext</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">showNewFeature</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">runNewPaymentLogic</span><span class="o">();</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">runOldPaymentLogic</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The real power is Targeting Rules. The code is deployed to all servers, but you control who can access the feature through the dashboard, without redeploying:</p>

<ul>
  <li>Enable only for QA: if <code class="language-plaintext highlighter-rouge">user_id = "qa_tester_bob"</code>, return <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li>Enable for a region: if <code class="language-plaintext highlighter-rouge">user_region = "EU"</code>, return <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li>Gradual business rollout: 5% of users today, 50% next week, 100% after validation.</li>
</ul>

<p>This is different from Canary Deployment. Canary is about infrastructure: deploy to a small percentage of servers to check if the code is stable. Feature Flags are about business logic: the code runs everywhere, but you choose which users can see the feature.</p>

<h2 id="safe-deployment-canary-releases">Safe Deployment: Canary Releases</h2>

<p>To deploy continuously without crashing Prod, teams use Canary Deployments:</p>

<ol>
  <li>Deploy v2.0 alongside v1.0.</li>
  <li>Route a small percentage of traffic to v2.0.</li>
  <li>Automated monitoring checks for errors (HTTP 500s, latency spikes).</li>
  <li>If error rate &lt; threshold, gradually ramp up traffic to 100%.</li>
  <li>If errors spike, automatically rollback to v1.0.</li>
</ol>

<p>The goal: Make deployment a boring, non-event that happens constantly.</p>

<h2 id="environments-ephemeral-over-static">Environments: Ephemeral over Static</h2>

<p>In the traditional model, you had static environments: Dev, QA, UAT, Prod. These servers were always running, often drifted from Prod configurations, and were bottlenecks.</p>

<p>In Continuous Deployment, this changes to Ephemeral Environments:</p>

<ul>
  <li><strong>Local</strong>: Developer works on their machine (Docker to mimic Prod).</li>
  <li><strong>Preview Environment</strong>: Auto-created when a PR is opened. Tests run here. QA clicks a link to verify. Destroyed after merge.</li>
  <li><strong>Staging (Pre-Prod)</strong>: Single environment mirroring Prod exactly. Auto-deploys to Prod if smoke tests pass.</li>
</ul>

<p>Do you need a permanent QA server? No. You create a fresh one for every feature, test it, and destroy it.</p>

<h2 id="branching-trunk-based-development">Branching: Trunk-Based Development</h2>

<p>The industry standard for Continuous Deployment is Trunk-Based Development.</p>

<p><strong>Old Way (GitFlow):</strong> You have Master, Develop, Feature-X, Release-1.0. Code lives in a feature branch for weeks. Merging is painful.</p>

<p><strong>New Way (Trunk-Based):</strong></p>
<ul>
  <li>One Main Branch, usually called <code class="language-plaintext highlighter-rouge">main</code> or <code class="language-plaintext highlighter-rouge">trunk</code>.</li>
  <li>Short-Lived Feature Branches: Developers create a branch and merge it back to <code class="language-plaintext highlighter-rouge">main</code> within 24 hours.</li>
  <li>No Release Branches: You deploy a specific commit from <code class="language-plaintext highlighter-rouge">main</code>.</li>
</ul>

<p>How can you merge unfinished work? You merge the backend code but hide it behind a Feature Flag. Your code is integrated with everyone else’s code daily. You never have merge conflicts because you never drift far from <code class="language-plaintext highlighter-rouge">main</code>.</p>

<h2 id="measuring-success-dora-metrics">Measuring Success: DORA Metrics</h2>

<p>The Accelerate book introduces four metrics that have become the industry standard:</p>

<ul>
  <li><strong>Deployment Frequency</strong>: How often you deploy to production. High performers: multiple times per day.</li>
  <li><strong>Lead Time for Changes</strong>: Time from commit to production. High performers: less than one hour.</li>
  <li><strong>Time to Restore Service</strong>: How quickly you recover from incidents. High performers: less than one hour.</li>
  <li><strong>Change Failure Rate</strong>: Percentage of deployments causing failures. High performers: 0-15%.</li>
</ul>

<p>The counter-intuitive finding: Teams that deploy multiple times a day have lower change failure rates than teams that deploy monthly. Smaller changes mean smaller blast radius and easier rollback.</p>

<h2 id="accelerating-even-faster">Accelerating Even Faster</h2>

<p>Once deploying is no longer the challenge, the focus shifts to making pipelines smarter.</p>

<h3 id="1-predictive-test-selection">1. Predictive Test Selection</h3>

<p>Running 2,000 tests for a one-line CSS change is a waste of resources. If your regression suite takes 30 minutes, that adds up when you deploy multiple times a day.</p>

<p><strong>CloudBees Smart Tests</strong> analyzes your Git history and test failures. It tells your pipeline: only run these 50 tests, skip the other 2,000.</p>

<p><strong>Gradle Develocity</strong> (formerly Gradle Enterprise) is the gold standard for Java/Spring shops. It caches test results and uses ML to skip tests that haven’t been impacted by your code changes.</p>

<p><strong>Harness Test Intelligence</strong> builds a call graph of your code. If you change <code class="language-plaintext highlighter-rouge">Login.java</code>, it knows exactly which tests cover that file.</p>

<p>Feedback time drops from 30 minutes to 5 minutes.</p>

<h3 id="2-deployment-risk-scoring">2. Deployment Risk Scoring</h3>

<p>Most CD tools like ArgoCD are dumb. They just sync Git to Cluster. They don’t know if the app is actually working, only that the pod is running.</p>

<p><strong>OpsMx Autopilot</strong>: The brain you attach to your muscle (ArgoCD or Spinnaker). It connects to your logs (Splunk, Datadog) and metrics (Prometheus). When you deploy to Staging, it compares the new version against the old one in real-time and assigns a Risk Score (0-100). If the score drops below 90, it automatically commands ArgoCD to rollback. This automates the Canary Analysis that usually requires a senior engineer staring at a dashboard for 30 minutes.</p>

<p><strong>Harness Continuous Verification</strong>: Similar approach. Connects to your monitoring. Uses ML to compare versions. Auto-rolls back if errors deviate by more than 1%.</p>

<p>This replaces blanket approval rules with smart rules based on actual risk.</p>

<h3 id="3-smart-root-cause-analysis">3. Smart Root Cause Analysis</h3>

<p>When a build fails, someone has to dig through 1,000 lines of logs. When Production alerts fire at 3 AM, someone has to correlate logs, traces, and recent deployments.</p>

<p><strong>Komodor</strong> tracks every single change in Kubernetes (config, deploy, health check) and correlates it to failures. Like a Time Machine for K8s.</p>

<p><strong>Dynatrace Davis AI</strong> uses deterministic AI (not just ML guessing) to analyze the dependency graph. It can tell you: “The user login failed because the backend SQL database was locked by the Inventory Service.”</p>

<p><strong>Datadog Bits AI</strong> lets you ask in natural language: “Who deployed to the payment service right before the latency spike?” It correlates the Git commit to the error logs.</p>

<p><strong>Harness AIDA</strong> (AI DevOps Agent) scans logs and Git history, then generates a summary: “Failure likely caused by memory leak in commit 8a4b2 by User X.”</p>

<h3 id="4-gitops-from-push-to-pull">4. GitOps: From Push to Pull</h3>

<p>This is the standard operating model now. You don’t use a UI like Jenkins to deploy. You commit a change to a config file in Git, and an agent inside the Production cluster pulls the change in.</p>

<p><strong>The Old Way (Push Model, Jenkins style):</strong></p>
<ol>
  <li>Developer commits code.</li>
  <li>Jenkins builds the artifact.</li>
  <li>Jenkins runs: <code class="language-plaintext highlighter-rouge">kubectl apply -f my-app.yaml</code>.</li>
</ol>

<p>The Risk: A debug flag gets enabled directly in the cluster during troubleshooting. The issue gets fixed, but the flag stays on for weeks. Git and Production are now out of sync.</p>

<p><strong>The New Way (Pull Model):</strong></p>
<ol>
  <li>Developer commits code or config to Git.</li>
  <li>CI only updates a Docker image registry.</li>
  <li>An Agent living inside the Production Cluster asks: Does my current state match what is in Git?</li>
  <li>It sees a new image tag in Git. It pulls the change and applies it.</li>
</ol>

<p>Why is this safer?</p>

<ul>
  <li><strong>Drift Detection</strong>: If someone changes a setting in Prod manually, the agent detects the drift immediately and can auto-revert.</li>
  <li><strong>Security</strong>: You don’t give your CI server Admin Access to your Prod cluster. The cluster reaches out to Git; nothing reaches in.</li>
</ul>

<p><strong>ArgoCD</strong>: The clear winner. Best UI for visualizing Kubernetes. Logs exactly who merged the PR that triggered the sync.</p>

<p><strong>Flux v2</strong>: If you want it invisible. No UI; it just works in the background.</p>

<p><strong>Harness GitOps</strong>: Managed ArgoCD with an enterprise UI and dashboards.</p>

<h3 id="5-finops-integration">5. FinOps Integration</h3>

<p>The frontier between development teams and infrastructure teams is becoming fuzzy. A feature might have an impact on the infrastructure. It should be considered during the CI/CD phase.</p>

<p>In the cloud, developers have infinite resources. A junior dev can accidentally provision a database that costs $5,000/month, and you won’t know until the bill arrives 30 days later. The fix: shift cost analysis into the Pull Request.</p>

<p><strong>For Terraform:</strong> The industry standard is Infracost. It parses your Terraform code, compares it against a cloud pricing API, and posts a comment on your Pull Request showing the price difference.</p>

<p>Developer changes an AWS EC2 instance from <code class="language-plaintext highlighter-rouge">t3.micro</code> to <code class="language-plaintext highlighter-rouge">m5.large</code>. CI runs <code class="language-plaintext highlighter-rouge">infracost breakdown --path .</code> and comments on the PR:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cost Increase: +$65/month
Create aws_instance.app_server: +$72.00
Remove aws_instance.old_server: -$7.00
</code></pre></div></div>

<p><strong>For Kubernetes/Helm:</strong> Harder because Kubernetes files list generic CPU/RAM requests, not instance types. The cost depends on which node the pod lands on.</p>

<p>Kubecost / OpenCost handles this with the <code class="language-plaintext highlighter-rouge">kubectl cost predict</code> command. The trick: you cannot scan a raw Helm chart easily. You must render it first with <code class="language-plaintext highlighter-rouge">helm template . &gt; final_manifest.yaml</code>, then run the prediction.</p>

<p><strong>Vantage</strong>: The modern, startup-friendly alternative. Connects to AWS/GCP and gives you a Cost per Tenant view.</p>

<p><strong>Harness Cloud Cost Management</strong>: Does both Terraform and Kubernetes natively. Has a policy engine built-in: you can set a rule to block any PR that increases the monthly forecast by more than $500.</p>

<h2 id="the-bleeding-edge-agentic-devops">The Bleeding Edge: Agentic DevOps</h2>

<p>The industry is moving from Automated Pipelines to AI Agents.</p>

<p><strong>Old Way (Automated):</strong> The pipeline fails. You get an alert. You read the log. You fix it.</p>

<p><strong>New Way (Agentic):</strong> The pipeline fails. An AI Agent reads the log, writes a fix, and opens a PR for you to approve.</p>

<p>This is what high-performing tech companies are building towards. Tools like OpsMx (Verification) and Komodor (Troubleshooting) are the answers to the 3 AM problem. They use data to fix or revert things before you even open your laptop.</p>

<h2 id="summary">Summary</h2>

<p>Tools I looked at:</p>

<table>
  <thead>
    <tr>
      <th>Capability</th>
      <th>Tool</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Predictive Test Selection</td>
      <td>CloudBees Smart Tests, Gradle Develocity</td>
    </tr>
    <tr>
      <td>Deployment Risk Scoring</td>
      <td>OpsMx Autopilot</td>
    </tr>
    <tr>
      <td>Root Cause Analysis</td>
      <td>Komodor, Dynatrace Davis AI, Datadog Bits AI</td>
    </tr>
    <tr>
      <td>GitOps</td>
      <td>ArgoCD, Flux v2</td>
    </tr>
    <tr>
      <td>FinOps</td>
      <td>Infracost (Terraform), Kubecost (K8s)</td>
    </tr>
  </tbody>
</table>

<p>Harness covers all of this in one platform:</p>

<table>
  <thead>
    <tr>
      <th>Requirement</th>
      <th>Harness Module</th>
      <th>How it works</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Predictive Test Selection</td>
      <td>Test Intelligence</td>
      <td>Builds a call graph, runs only relevant tests</td>
    </tr>
    <tr>
      <td>Deployment Risk Scoring</td>
      <td>Continuous Verification</td>
      <td>ML compares new vs old version, auto-rollback if errors spike</td>
    </tr>
    <tr>
      <td>Smart Root Cause Analysis</td>
      <td>AIDA</td>
      <td>Scans logs and Git history, generates failure summary</td>
    </tr>
    <tr>
      <td>GitOps</td>
      <td>Harness GitOps</td>
      <td>Managed ArgoCD with enterprise UI</td>
    </tr>
    <tr>
      <td>FinOps</td>
      <td>Cloud Cost Management</td>
      <td>Calculates cost impact in PR, can block on budget</td>
    </tr>
  </tbody>
</table>

<h2 id="recommended-reading">Recommended Reading</h2>

<p><strong>Accelerate: The Science of Lean Software and DevOps</strong> (Forsgren, Humble, Kim)</p>

<p>This book uses rigorous statistical data to prove that High Performers who deploy multiple times a day have lower change failure rates than Low Performers who deploy monthly. It is essential reading for understanding why Continuous Deployment is actually safer than the traditional approach.</p>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2025-12-29T00:00:00+01:00">December 29, 2025</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/blogging/2025/11/30/AI_Java.html" class="pagination--pager" title="Running AI Models in Java without Python">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  
</div>

      
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>


<div class="page__footer-copyright">&copy; 2025 <a href="http://localhost:4000">Cognitive offloading</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>









  </body>
</html>
