---
layout: post
title: "Building RAG Systems in Java"
date: 2025-11-29
categories: [blogging]
---

Building RAG Systems in Java

After the python version, I wanted to verify if you can build a Retrieval-Augmented Generation (RAG) system from scratch in Java.

The Challenge

Python has become the de facto language for AI/ML projects, and for good reason—excellent libraries, rapid prototyping, and a mature ecosystem. But I wanted to explore whether
enterprise-grade RAG systems could be built with the same effectiveness in Java, particularly for production environments.

The Implementation

I built MCP Server 4J, a Model Context Protocol server implementing hybrid search (BM25 + vector similarity) with:

- Apache Lucene for BM25 keyword indexing
- LangChain4j for vector embeddings and ChromaDB integration
- Spring Boot for dependency injection and configuration management

Key Findings

What Works Well:

- Type safety catches errors at compile time, not runtime
- Spring Boot's DI container makes testing straightforward
- Apache Lucene provides native, production-ready BM25 implementation

Java Has Everything You Need:

- Apache Lucene provides industrial-strength BM25 ranking
- LangChain4j brings vector embeddings and model integrations
- ONNX runtime eliminates Python dependencies entirely
- The ecosystem is mature and production-ready

The Java Advantage:

- Interfaces (KeywordIndexer, DocumentLoader, DocumentChunker) make the system testable and extensible
- Type safety means errors show up in my IDE, not in production

The Tradeoffs:

- 10x more code than the Python equivalent (~2000 lines vs ~200)
- Longer development cycles for initial implementation
- Higher memory footprint (~500MB vs ~200MB)
- More complex build tooling (Maven vs pip)

The performance is essentially identical—20-30ms query latency with hybrid search combining BM25 and vector similarity. The real difference isn't runtime performance; it's
development confidence.

Lessons Learned

1. RAG is definitely achievable in Java. The ecosystem has matured significantly with LangChain4j, Apache Lucene, and ONNX runtime support.
2. Enterprise patterns matter at scale. What feels like over-engineering in Python (factories, interfaces, dependency injection) becomes valuable when you have multiple
   teams working on the same codebase.
3. Choose the right tool for the job. Python excels at rapid prototyping and research. Java shines in production environments where you need strong contracts, clear
   interfaces, and long-term maintainability.

The Verdict

Can you build RAG systems in Java? Absolutely. Should you? It depends on your requirements:

Choose Java if:

- You need strong type safety and compile-time guarantees
- Your team is already in the JVM ecosystem
- You're building production systems requiring clear interfaces
- Long-term maintainability is a priority

Stick with Python if:

- You're in research/prototype phase
- Team expertise is primarily Python
- You need access to cutting-edge model libraries
- Development speed trumps type safety

For production RAG systems serving real users, I'd confidently deploy the Java version. The additional development time is offset by fewer runtime surprises and clearer
system boundaries.

Technical Details

The complete implementation includes:

- 76 unit tests + integration tests with Testcontainers
- Hybrid search with configurable BM25/vector weights
- Multi-format document support (PDF, Markdown, TXT)
- ~20-30ms query latency with 100% recall@5 on test queries

The full source is available on GitHub for anyone interested in exploring RAG beyond the Python ecosystem: https://github.com/jeremylem/mcp_server4j
